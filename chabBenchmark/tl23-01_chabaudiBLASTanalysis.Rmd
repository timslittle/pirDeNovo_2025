---
title: "tl23-01_chabaudiBLASTanalysis"
output: 
  html_document:
    theme: cosmo
    code_download: true
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

# Intro

This script is looks at the BLAST results of a _de novo_ assembled transcriptome. 

# What this report shows:

*The level of counts / TPM of pirs that are detected by the Trinity de novo assembled transcriptome.

**e.g. What is the minimum expressed gene detected / What is the maximally expressed gene not detected.

# To-do:

*Check how they BLAST to the rest of the transcriptome, do pir de novo transcripts also BLAST to non-pir transcripts?

*Select the most informative data and poo-poo the rest.

*Save useful files made by this script as csv.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      results = TRUE, 
                      message = TRUE, 
                      warning = TRUE)
options(scipen = 999) # Means that numbers are displayed normally not as 1e6 (1000000)
```

```{r loading_packages, include = FALSE, message = FALSE}
# Load the required packages
library('readr')
library('dplyr', 
        # lib.loc = "/nemo/home/littlet/R/x86_64-pc-linux-gnu-library/4.0"
        )
library('stringr')
library('purrr')
# library('IRanges')
library('kableExtra')
library('plotly')
# library('seqinr')
library('rmarkdown')
library('data.table')
library('xlsx')
```

```{r function_ordering}
ordering <- function(to_order, order_vector, fromLast = TRUE){
  order = unlist(sapply(order_vector, 
                        function(x){unique(str_subset(to_order, 
                                                      pattern = paste(x)))}))
  order_missing = unique(to_order[!to_order %in% order])
  unique(c(order, order_missing), fromLast = fromLast)
}
```

```{r function_alternateReverse}
alternateReverse <- function(input.vec){
  #Alternate the indexes of a vector, with one alternation in reverse order.
  # Good for colour systems so the end of a gradient is shifted between very different colours.
  output.vec <- c(rbind(input.vec[seq_along(input.vec)%%2==1], 
                        rev(input.vec[seq_along(input.vec)%%2==0])))
  if(length(output.vec) != length(input.vec)){
    #If input.vec is odd length rbind will add an extra value at the end.
    # So the length will be longer, this removes the last, erroneous element.
    return(output.vec[-last(output.vec)])
  }else{
    return(output.vec)
  }
}
```

```{r load_data}
pir.info <- read.delim('Pchabaudi_pir_info.txt', sep = '\t')

counts <- read.csv('tl19-07_twentyfour_counts_samples.csv',
                   header = TRUE,
                   stringsAsFactors = FALSE) %>% 
  filter(Geneid %in% pir.info$Gene.ID) %>% 
  select(colnames(.)[order(colnames(.))])

tpm_data <- read.csv('tl19-07_twentyfour_tpm_samples.csv',
                   header = TRUE,
                   stringsAsFactors = FALSE) %>% 
  filter(Geneid %in% pir.info$Gene.ID) %>% 
  select(colnames(counts)[order(colnames(counts))])
```

```{r filter_nident}
#Set a filter for bp length to assume is a valid match
filter_nident <- 100
```

Filtering matches by a minimum of `r filter_nident`bp to be a valid match.

```{r read_blast_results}
# list.files('../blast', pattern = 'outfmt')

outfmt6_headers <- 
  'qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs qcovhsp slen nident' %>% 
  strsplit(split = ' ') %>% 
  unlist

blast_files <- c(
  list.files(path = "../../blast", 
             pattern = "blastp.outfmt6",
             full.names = TRUE),
  # list.files(path = "../../blast/chabaudi/", 
  #            pattern = "CDS.blast",
  #            full.names = TRUE),
  list.files(path = "../../blast/chabaudi", 
             pattern = "evigene",
             full.names = TRUE)
)
# 
# blast <- lapply(blast_files, 
#                 function(blast_output_file){
#                   
#                   blast_name <- str_extract(blast_output_file, 
#                                             pattern = '(?<=\\/)21659_.+(?=(2pir|_blast))') %>% 
#                     str_replace_all(pattern = '#', replacement = '_') %>% 
#                     str_remove_all(pattern = 'chabaudi_')
#                   
#                   sample_name <- str_extract(blast_output_file, 
#                                              pattern = '(?<=\\/)21659_8.[[:digit:]]{1,2}') %>% 
#                     str_replace_all(pattern = '#', replacement = '_') %>% 
#                     str_remove_all(pattern = 'chabaudi_')
#                   
#                   assembler_name <- str_extract(blast_output_file, 
#                             pattern = 'spadesSC|spadesRNA|trinity|evigene|multiass')
#                   
#                   cdhit_thresh <- str_extract(blast_output_file, 
#                                                            pattern = 'cdhit(|est)[[:digit:]]{2}') %>% 
#                     str_replace(pattern = 'cdhitest', replacement = 'cdhit')
#                   
#                   read.table(blast_output_file,
#                              col.names = outfmt6_headers) %>% 
#                     mutate(geneid = str_extract(sseqid, 
#                                                 pattern = '.+(?=\\.)'),
#                            # sseqid = unlist(
#                            #   lapply(
#                            #     str_extract_all(sseqid, 
#                            #                     pattern = '.+(?=\\.)'), 
#                            #     paste, 
#                            #     collapse = '_')
#                            # ),
#                            scovhsp = round( (nident/slen * 100), digits = 2),
#                            scovs = round(((abs(send - sstart) + 1)/slen *100), digits = 2),
#                            evalue = format(evalue, scientific = TRUE),
#                            blast_name = blast_name,
#                            sample_name = sample_name,
#                            assembler_name = assembler_name,
#                            cdhit_thresh = cdhit_thresh
#                     ) %>% 
#                     # Filter for minimum identity and pir gene name.
#                     filter(nident > filter_nident,
#                            geneid %in% pir.info$Gene.ID) %>%
#                     group_by(qseqid) %>% 
#                     mutate(num_genes_match =  dplyr::n_distinct(geneid))
#                 }) %>% dplyr::bind_rows()
# 
# write_csv(blast,
#           path = '../../blast/chabaudi_blastp_results.csv')

blast <- read_csv('../../blast/chabaudi_blastp_results.csv')

mutate(blast, sample = paste(sample_name, assembler_name, cdhit_thresh, sep = '_')) %>% .$sample %>% unique %>% sort %>% length() == 216

# names(blast) <- str_extract(blast_files, 
#                             pattern = '(?<=\\/)21659_.+(?=(2pir|_blastp))') %>% 
#   str_replace_all(pattern = '#', replacement = '_') %>% 
#   str_remove_all(pattern = 'chabaudi_')
# 
# sample_names <- unique(str_extract(blast_files, 
#                             pattern = '(?<=\\/)21659_8.[[:digit:]]{1,2}')) %>% 
#   str_replace_all(pattern = '#', replacement = '_') %>% 
#   str_remove_all(pattern = 'chabaudi_')
# 
# assembler_names <- unique(str_extract(blast_files, 
#                             pattern = 'spadesSC|spadesRNA|trinity|evigene'))

```

# Coverage of the subject (known transcripts) and query (assembled de novo transcripts) sequences. 

Using only the de novo transcripts that uniquely match one known pir transcript.

For our purposes the subject coverage is probably most important.

```{r scov_v_qcov}
# fig <- plot_ly(
#   blast_uniq,
#   x = ~qcovhsp,
#   y = ~scovhsp,
#   text = ~paste(sseqid)
# ) %>% 
#   layout(xaxis = list(title = "De novo transcript coverage"),
#          yaxis = list(title = "Known transcript coverage"))
# fig
```

Number of unique genes found by BLAST: `r unique(blast$sseqid) %>% length`.

# Known transcripts with >95% coverage from one de novo transcript.

How many of the known transcripts are covered >=95% of their sequence by de novo transcripts, with >=95% identity?

num_match_all and num_match_95 show how many other known transcripts these de novo transcripts match in total or >=95% respectively.

```{r transcripts_covering_most_of_known_transcripts}
# transcripts_covered_by_denovo <- lapply(blast, function(blast_df){
#   transcripts_covered_by_denovo_df <- blast_df %>% 
#     group_by(qseqid) %>%
#     mutate(num_match_all = n_distinct(sseqid)) %>%
#     group_by(sseqid) %>% 
#     filter(scovhsp >= 95) %>% 
#     group_by(qseqid) %>%
#     mutate(num_match_95 = n_distinct(sseqid)) %>% 
#     arrange(geneid)
#   
#   transcripts_covered_by_denovo_75 <- blast_df %>% 
#   group_by(qseqid) %>%
#   mutate(num_match_all = n_distinct(sseqid)) %>%
#   group_by(sseqid) %>% 
#   filter(scovhsp >= 75) %>% 
#   group_by(qseqid) %>%
#   mutate(num_match_95 = n_distinct(sseqid)) %>% 
#   arrange(geneid)
#   
#   possible_chimeras <- transcripts_covered_by_denovo_df %>% 
#   filter(qcovhsp < 50)
#   
#   return(list(blast_df = blast_df,
#               transcripts_covered_by_denovo_df = transcripts_covered_by_denovo_df,
#               possible_chimeras = possible_chimeras,
#               transcripts_covered_by_denovo_75 = transcripts_covered_by_denovo_75
#   ))
# })
```

Showing the BLAST alignments of these >=95% coverage de novo transcripts in a graph, and all the matches they have. 
The "n =" number after the transcript name shows how many other BLAST hits the de novo transcript had in total.
Size of each point shows the length of the alignment.

Evigene appears to have few possible chimeras, is it removing them? Do the hits to ancestral still remain? Is this because it's matched to CDS instead?

```{r sample_assembly_list}
# sample_blast.list <- lapply(sample_names, 
#                             function(sample){
#                               assembler.list <- lapply(c('evigene', 'spadesRNA', 'spadesSC', 'trinity'), 
#                                                        function(assembler){
#                                                          getElement(transcripts_covered_by_denovo, 
#                                                                     str_subset(names(transcripts_covered_by_denovo),
#                                                                                 pattern = paste0(sample, '_(.+|)', assembler))
#                                                          )
#                                                        })
#                               names(assembler.list) <- c('evigene', 'spadesRNA', 'spadesSC', 'trinity')
#                               return(assembler.list)
#                             })
# names(sample_blast.list) <- sample_names
```
# Transcripts matched by percentage coverage.

```{r transcript_coverage_by_percentage}

blast_forcov.df <- blast %>%
  group_by(geneid, blast_name) %>%
  #Choosing this by bitscore scovhsp or pident may be important
  slice_max(order_by = bitscore, n = 1, with_ties = FALSE) %>%
  # #Only keep the row with the lowest mismatches (again, may be important whether this or gaps are chosen).
  # slice_min(order_by = mismatch, n = 1) %>% 
  group_by(blast_name,
           sample_name, assembler_name,
           cdhit_thresh) 

cvrg_df <- lapply( seq(5,100,by = 5),
  function(cvrg) {
    lapply(c(100, 90, 75),
           function(percident){
             summarise(blast_forcov.df,
                       num_matches = n_distinct(sseqid[scovhsp >= cvrg & pident >= percident]),
                       gapopens = median(gapopen),
                       mismatches = median(mismatch)) %>% 
               mutate(cvrg = cvrg, percident = percident)
           })
  }) %>% bind_rows %>% arrange(desc(num_matches))

cvrg_df %>% filter(sample_name == '21659_8_5', cvrg == 75, percident == 75)
```

```{r percident_graph}
cols_pident <- as.factor(cvrg_df$pident) %>% 
  as.integer()
cols_plot <- hcl.colors(length(unique(cols_pident)), palette = "Spectral")[cols_pident]

lapply(cvrg_df$sample_name[1], 
       function(sample_name.str){
         ggplot(data = filter(cvrg_df, 
                              sample_name == sample_name.str,
                              is.na(cdhit_thresh),
                              cvrg > 50)) +
           geom_line(aes(y = num_matches, 
                         x = cvrg,
                         linetype = as.factor(percident),
                         col = assembler_name),
                     size = .75) +
           scale_linetype_manual(values = c('100' = 2, '90' = 1, '75' = 4), 
                                 name = '% identity') +
           theme_classic() +
           ylab('Number of known transcripts covered') +
           xlab('Percentage of coverage by individual transcripts') +
           facet_grid(rows = vars(assembler_name)) +
           ggtitle(sample_name.str)
})
```

Something is wrong with the below, it's producing weird numbers for the multiass.

```{r cvrg_stats}
#define custom function to calculate min
custom_min <- function(x) {if (length(x)>0) min(x) else NA}
custom_max <- function(x) {if (length(x)>0) max(x) else NA}

transcriptCvrg.df <- lapply(c(50,75,90,95,100), 
                            function(threshold){
                              transcripts_df <- blast_forcov.df %>% 
                                # filter(scovhsp >= threshold,
                                # pident >= 95) %>%
                                group_by(assembler_name, sample_name, cdhit_thresh) %>% 
                                summarise(num_transcripts = n_distinct(sseqid[scovhsp >= threshold &
                                                                                pident >= 95]),
                                          min_test = custom_min(scovhsp[scovhsp >= threshold &
                                                                   pident >= 95]),
                                          num_deNovo = length(qseqid[scovhsp >= threshold &
                                                                       pident >= 95]),
                                          med_mismatch = median(mismatch[scovhsp >= threshold &
                                                                           pident >= 95]),
                                          med_gap = median(gapopen[scovhsp >= threshold &
                                                                     pident >= 95]),
                                          min_scovhsp = custom_min(qcovhsp[scovhsp >= threshold &
                                                                      pident >= 95]),
                                          max_scovhsp = custom_max(qcovhsp[scovhsp >= threshold &
                                                                      pident >= 95])) %>% 
                                mutate(threshold = threshold) 
                            }) %>% bind_rows()
# 
# transcriptCvrg.df %>% filter(sample_name == '21659_8_16', !is.na(cdhit_thresh), assembler_name == 'multiass')
# 
# blast_forcov.df %>% filter(sample_name == '21659_8_16', 
#                            !is.na(cdhit_thresh), 
#                            assembler_name == 'multiass',
#                            pident >= 95,
#                            scovhsp >= 50,
#                            # sseqid == 'PCHAS_1200200.1-p1'
#                            ) 
  
```

```{r}

(gplot <- ggplot(transcriptCvrg.df, 
                aes(x = assembler_name, 
                    y = num_transcripts,
                    col = assembler_name)) +
  geom_boxplot() +
  theme_classic() +
  theme(axis.text.x = element_blank()) +
  xlab('Method of transcriptome assembly/meta-assembly') +
  ylab('Number of known transcripts matched') +
  facet_grid(~ threshold + cdhit_thresh, scales = 'free_x'))

# ggsave(filename = '../../plots/chabaudi_numTranscriptsPerAssembByCvrg.pdf',
#        plot = gplot)

```

```{r mismatches}

transcriptCvrg_MultiEvi.df <- filter(transcriptCvrg.df, 
                                     assembler_name %in% c('multiass','evigene'),
                                     threshold != 100
                                     )

ggplot(data = transcriptCvrg_MultiEvi.df,
       aes(y = med_mismatch,
           # size = num_deNovo,
           x = num_transcripts,
           col = paste(assembler_name, cdhit_thresh, sep = '_'),
           shape = as.factor(threshold))) +
  geom_jitter(alpha = 0.75, size = 2) +
  facet_wrap(~ paste(assembler_name, cdhit_thresh, sep = '_')) +
  theme_classic()

ggplot(data = transcriptCvrg_MultiEvi.df,
       aes(y = min_scovhsp,
           # size = num_deNovo,
           x = num_transcripts,
           # col = paste(assembler_name, cdhit_thresh, sep = '_'),
           shape = as.factor(threshold))) +
  geom_jitter(alpha = 0.75, size = 2) +
  facet_wrap(~ paste0(assembler_name, 
                     ifelse(is.na(cdhit_thresh), '', '_cdhit95'))) +
  theme_classic()
```


```{r uniq_transcripts}

transcripts.df <- lapply(names(sample_blast.list),
       function(sample) {
         assembly_blast.list <- getElement(sample_blast.list, sample)
         lapply(names(assembly_blast.list), function(assembler) {
           assembly_df <- getElement(assembly_blast.list, assembler)
           transcripts_df <- assembly_df$transcripts_covered_by_denovo_df %>% 
             filter(scovhsp >= 95) %>% 
             mutate(assembler = assembler,
                    sample = sample) %>%
             group_by(assembler, sample)
           return(transcripts_df)
         })
       }) %>% bind_rows

uniq_genes <- unique(data.table(transcripts.df), by = c("sample","sseqid")) %>% 
  select(qseqid, sseqid, assembler, sample, everything()) %>% 
  # filter(assembler != 'evigene') %>% 
  arrange(sseqid, sample)

filter(transcripts.df, sseqid == 'PCHAS_0200005.1') %>% 
  select(qseqid, sseqid, assembler, sample, everything()) %>% 
  arrange(sample)

```

'PCHAS_0213821' only matched by spadesRNA transcripts, 'PCHAS_1200500' only by spadesRNA/SC.

```{r evigene_v_rest}
evigene_v_rest <- lapply(names(sample_blast.list),
                         function(sample) {
                           assembly_blast.list <- getElement(sample_blast.list, sample)
                           lapply(c('evigene','rest'), 
                                  function(assembler) {
                                    if(assembler == 'evigene'){
                                      assembly_df <- getElement(assembly_blast.list, 
                                                                assembler)$transcripts_covered_by_denovo_df
                                      
                                    } else {
                                      assembly_df <- bind_rows(lapply(assembly_blast.list[!names(assembly_blast.list) %in% 
                                                                                            'evigene'], 
                                                                      getElement, 
                                                                      'transcripts_covered_by_denovo_df'))
                                    }
                                    
                                    transcripts_df <- assembly_df %>% 
                                      filter(scovhsp >= 95) %>% 
                                      mutate(assembler = assembler,
                                             sample = sample) %>%
                                      group_by(assembler, sample) %>% 
                                      summarise(num_transcripts = n_distinct(sseqid),
                                                num_deNovo = length(qseqid),
                                                med_mismatch = median(mismatch),
                                                med_gap = median(gapopen),
                                                min_scovhsp = min(qcovhsp),
                                                max_scovhsp = max(qcovhsp))
                                    if(nrow(transcripts_df) == 0) {
                                      transcripts_df <- data.frame('assembler' = assembler,
                                                                   'sample' = sample,
                                                                   'num_transcripts' = 0,
                                                                   'num_deNovo' = 0)
                                    }
                                    return(transcripts_df)
                                  })
                         }) %>% bind_rows

ggplot(evigene_v_rest, aes(x = assembler, 
                              y = num_transcripts)) +
  geom_boxplot() +
  geom_point(aes(col = sample)) +
  geom_line(aes(col = sample, group = sample)) +
  theme_classic() +
  theme(legend.position = 'none')
```

# Save BLAST hits for supplementary info.

```{r suppl_blast_hits}

uniq_genes_id <- apply(uniq_genes[,c('qseqid','sseqid','sample')],
                       1,
                       paste,
                       collapse = ' ')

blast_hits.df <- lapply(names(sample_blast.list),
                        function(sample) {
                          assembly_blast.list <- getElement(sample_blast.list, sample)
                          lapply(names(assembly_blast.list), function(assembler) {
                            assembly_df <- getElement(assembly_blast.list, assembler)
                            transcripts_df <- assembly_df$transcripts_covered_by_denovo_df %>% 
                              mutate(assembler = assembler,
                                     sample = sample) %>%
                              mutate(possible_chimera = ifelse(qcovhsp <= 50 && scovhsp >= 95, 
                                                               TRUE, 
                                                               FALSE),
                                     unique_assembly_match = ifelse(paste(qseqid, sseqid, sample) %in% 
                                                                      uniq_genes_id,
                                                                    TRUE,
                                                                    FALSE),
                                     uniq_id = paste(qseqid, sseqid, sample, 
                                                     collapse = '_')) %>% 
                            group_by(sample, assembler) %>% 
                              select(qseqid, sseqid, assembler, sample, everything(), -uniq_id)
                            return(transcripts_df)
                          })
       }) %>% bind_rows

# TODO: Fix, and remove row numbers
write.xlsx2(
  file = '../../supp_files/suppfile_blast_hits.xlsx',
  x = blast_hits.df
)

write_csv2(
  path = '../../supp_files/suppfile_blast_hits.csv',
  x = blast_hits.df
)

```

# BUSCO scores

```{r busco}
busco.files <- list.files(path = '../../../tl22-03_nfCoreTranscriptCorral/chab_test_results/busco/',
           pattern = "-plasmodium_odb10-busco.batch_summary.txt",
           full.names = TRUE)

busco.df <- lapply(busco.files, read.delim, sep = '\t') %>% bind_rows %>% arrange(desc(Complete))

write.xlsx2(
  file = '../../supp_files/suppfile_busco.xlsx',
  x = busco.df
)

write_csv2(
  path = '../../supp_files/suppfile_busco.csv',
  x = busco.df
)
```

```{r data_to_save}
number_transcripts <- system(paste0('cat ',
                                    params$assembly_file, 
                                    ' | grep ">" | wc -l'),
                             intern = TRUE)
# if(any_blast){
  number_knownCovOver95 <- length(unique(transcripts_covered_by_denovo$geneid))
  number_knownCovOver75 <- length(unique(transcripts_covered_by_denovo_75$geneid))
  
  number_knownCovOver95_idOver95 <-length(unique(filter(transcripts_covered_by_denovo, 
                                                        pident >= 95)$geneid))
  number_knownCovOver75_idOver95 <- length(unique(filter(transcripts_covered_by_denovo_75, 
                                                         pident >= 95)$geneid))
  
  
  number_knownCovOver95_deNovoCovUnder50 <- length(unique(filter(
    ungroup(transcripts_covered_by_denovo), 
    qcovhsp < 50
  )$geneid))
  
  number_knownCovOver95_idOver95_deNovoCovUnder50 <- length(unique(filter(
    ungroup(transcripts_covered_by_denovo), 
    qcovhsp < 50,
    pident >= 95
  )$geneid))
  
  ancestral_over95_id <- ifelse(
    any(grepl(transcripts_covered_by_denovo$sseqid,
              pattern = 'PCHAS_0101200')),
    paste(transcripts_covered_by_denovo$pident[
      grepl(transcripts_covered_by_denovo$sseqid,
            pattern = 'PCHAS_0101200')
    ], sep = '; '),
    0)
  ancestral_over75_id <- ifelse(
    any(grepl(transcripts_covered_by_denovo_75$sseqid,
              pattern = 'PCHAS_0101200')),
    paste(transcripts_covered_by_denovo_75$pident[
      grepl(transcripts_covered_by_denovo_75$sseqid,
            pattern = 'PCHAS_0101200')
    ], sep = '; '),
    0)
  
  mean_mismatches = mean(transcripts_covered_by_denovo$mismatch)
  mean_gaps = mean(transcripts_covered_by_denovo$gapopen)
  med_mismatches = median(transcripts_covered_by_denovo$mismatch)
  med_gaps = median(transcripts_covered_by_denovo$gapopen)
# }else{
#   number_knownCovOver95 <- number_knownCovOver95_deNovoCovUnder50 <- 
#     ancestral_over95 <- mean_mismatches <- 
#     mean_gaps <- med_mismatches <- med_gaps <- 0
# }
```

```{r data_save}
df_save <- data.frame(
  "assembly" = params$assembly_name,
  "num_transcripts" = number_transcripts,
  
  "knwn_trnscrpt_cvg_over75" = number_knownCovOver75,
  "knwn_trnscrpt_cvg_over75_idOver95" = number_knownCovOver75_idOver95,
  "ancestral_id_over75" = ancestral_over75_id,
  "knwn_trnscrpt_cvg_over95" = number_knownCovOver95,
  "knwn_trnscrpt_cvg_over95_idOver95" = number_knownCovOver95_idOver95,
  "knwn_trnscrpt_cvg_over95_deNovoCvgUnder50" = number_knownCovOver95_deNovoCovUnder50,
  "ancestral_id_over95" = ancestral_over95_id,
  
  "mean_mismatches" = mean_mismatches,
  "mean_gaps" = mean_gaps,
  "med_mismatches" = med_mismatches,
  "med_gaps" = med_gaps,
  
  "assembly_file" = params$assembly_file,
  "blast_file" = params$blast_output_file
) 

if(!file.exists('/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt') | params$new_table){
  #If table file doesn't exist then create it.
  write.table(df_save,
              file = '/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt',
              sep = '\t',
              col.names = TRUE,
              append = FALSE,
              row.names = FALSE)
} else if (params$assembly_name %in% read.delim('/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt')$assembly){
  #If assembly_name is already in table then overwrite it.
  assembly_info <- read.delim('/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt')
  assembly_info[assembly_info$assembly %in% params$assembly_name,] <- df_save[1,]
  write.table(assembly_info,
              file = '/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt',
              sep = '\t',
              row.names = FALSE)
} else {
  #Append to the existing table is both above are false
  write.table(df_save,
              file = '/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/tl21-01_assembly_info.txt',
              sep = '\t',
              col.names = FALSE,
              append = TRUE,
              row.names = FALSE)
}
df_save %>% 
  kbl() %>% kable_styling() %>% scroll_box(width = "100%", height = "400px")
```