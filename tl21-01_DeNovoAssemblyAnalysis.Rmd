---
title: "tl21-01_pirsInTheDeNovoAssemblies"
output: 
  html_document:
    theme: cosmo
    code_download: true
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

# Intro

This script is looks at the BLAST results of a Trinity _de novo_ assembled transcriptome. 

# What this report shows:

* The level of counts / TPM of pirs that are detected by the Trinity de novo assembled transcriptome.

** e.g. What is the minimum expressed gene detected / What is the maximally expressed gene not detected.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      results = TRUE, 
                      message = FALSE, 
                      warning = FALSE)
options(scipen = 999) # Means that numbers are displayed normally not as 1e6 (1000000)
```

```{r loading_packages, include = FALSE, message = FALSE}
# Load the required packages
library('readr')
library('dplyr', 
        lib.loc = "/camp/home/littlet/R/x86_64-pc-linux-gnu-library/4.0")
library('stringr')
library('purrr')
library('IRanges')
```

```{r function_ordering}
ordering <- function(to_order, order_vector, fromLast = TRUE){
  order = unlist(sapply(order_vector, 
                        function(x){unique(str_subset(to_order, 
                                                      pattern = paste(x)))}))
  order_missing = unique(to_order[!to_order %in% order])
  unique(c(order, order_missing), fromLast = fromLast)
}
```

```{r load_data}
pir.info <- read.delim('Pchabaudi_pir_info.txt', sep = '\t')

counts <- read.csv('tl19-07_twentyfour_counts_samples.csv',
                   header = TRUE,
                   stringsAsFactors = FALSE) %>% 
  filter(Geneid %in% pir.info$Gene.ID) %>% 
  select(matches('Geneid|SBP')) %>% 
  select(colnames(.)[order(colnames(.))])

sbp <- read.csv('tl19-07_twentyfour_tpm_samples.csv',
                   header = TRUE,
                   stringsAsFactors = FALSE) %>% 
  filter(Geneid %in% pir.info$Gene.ID) %>% 
  select(matches('Geneid|SBP')) %>% 
  select(colnames(counts)[order(colnames(counts))])
```

```{r check_tpm}

#Check that TPM all add to a million

# all(
#   sapply(apply(sbp[,-1], 2, sum),
#          all.equal,
#          1e6,
#          tolerance = 0.001)
# )
  
```

```{r read_blast_results}
# list.files('../blast', pattern = 'outfmt')

outfmt6_headers <- 
  'qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs qcovhsp slen nident' %>% 
  strsplit(split = ' ') %>% 
  unlist

blast <- read.table('/camp/lab/langhornej/working/HPC/littlet/tl21-01_testingTrinityChab24h/blast_pirDatabase/Trinity/trinity_blast_211124/trinityDeNovo_PirTranscriptsPccAS_blastn.outfmt6',
  col.names = outfmt6_headers) %>% 
  mutate(geneid = str_extract(sseqid, 
                              pattern = '(?<=gene=).+(?=___or)'),
         sseqid = unlist(
           lapply(
             str_extract_all(sseqid, 
                             pattern = '(?<=gene=).+(?=___or)|(?<=gene_product=).+(?=___trans)'), 
             paste, 
             collapse = '_')
         ),
         scovhsp = round( (nident/slen * 100), digits = 2),
         scovs = round(((abs(send - sstart) + 1)/slen *100), digits = 2),
         evalue = format(evalue, scientific = TRUE)
  )

#sanity test
# all(blast$scovs >= blast$scovhsp)
```

# Coverage of the subject (known transcripts) and query (assembled de novo transcripts) sequences.

For our purposes the subject coverage is probably most important.

```{r}
plot(blast$qcovhsp, blast$scovhsp, 
     xlab = 'De novo transcript coverage',
     ylab = 'Known transcript coverage')
```


Number of unique genes found by BLAST: `r unique(blast$sseqid) %>% length`.

# Top unique hits across the transcriptome.

```{r top_uniq_hits}
(blast_topNumHits <- blast %>% 
   group_by(sseqid) %>% 
   summarise(
     num = n(),
     max_id = max(pident),
     min_id = min(pident),
     max_nident = max(nident),
     min_nident = min(nident),
     max_gap = max(gapopen),
     min_gap = min(gapopen),
     max_qcovh = max(qcovhsp),
     min_qcovh = min(qcovhsp),
     max_scovh = max(scovhsp),
     min_scovh = min(scovhsp)
   ) %>% 
   arrange(desc(num)))
```

The gene with the greatest number of hits is `r blast_topNumHits[1,1]` with a max percentage id of `r blast_topNumHits$max_id[1]`.

# Number unique hits v counts/TPM

```{r uniq_hits_v_counts}
num_uniq_hits <- blast %>% 
  group_by(geneid) %>% 
  summarise(num = n()) %>% 
  arrange(geneid) %>% 
  filter(geneid %in% counts$Geneid)
```


```{r uniq_hits_v_counts}

total_counts_ofBlast <- filter(counts, 
                               Geneid %in% pir.info$Gene.ID) %>% 
  rowwise() %>% 
  mutate(geneid = Geneid,
  total_counts = sum(c_across(matches('SBP')))) %>% 
  select(c('geneid','total_counts'))

#Missing pir genes set to zero 
missing <- tibble(geneid = pir.info$Gene.ID[!pir.info$Gene.ID %in% num_uniq_hits$geneid],
                  num = 0)

num_uniq_hits <- rbind(num_uniq_hits,
                       missing) %>% 
  arrange(geneid)

total_tpm_ofBlast <- filter(sbp, 
       Geneid %in% pir.info$Gene.ID) %>% 
  arrange(Geneid) %>% 
  rowwise() %>% 
  mutate(geneid = Geneid, 
         total_tpm = sum(c_across(matches('SBP')))) %>% 
  select(c('geneid','total_tpm'))

# Combine the dfs

gene_transcription_df <- merge(merge(num_uniq_hits, 
                                     total_tpm_ofBlast),
                               total_counts_ofBlast)

#all(num_uniq_hits$geneid %in% total_counts_ofBlast$Geneid)

plot(log1p(gene_transcription_df$num), 
     log1p(gene_transcription_df$total_counts),
     xlab = 'Number of transcripts matching the gene',
     ylab = 'log Total gene counts + 1',
     xaxt = "n")
axis(1, at = log1p(c(0, 1, 2, 3, 5, 20, 50, 100)), labels = c(0, 1, 2, 3, 5, 20, 50, 100))

plot(log1p(gene_transcription_df$num), 
     log1p(gene_transcription_df$total_tpm),
     xlab = 'Number of transcripts matching the gene',
     ylab = 'log Total gene tpm + 1',
     xaxt = "n")
axis(1, at = log1p(c(0, 1, 2, 3, 5, 20, 50, 100)), labels = c(0, 1, 2, 3, 5, 20, 50, 100))

```
```{r cov_by_all_hits}
# Percentage of the subject covered by all hits
#  Need to make sure the order is always the same

blast_dir <- blast %>% 
  mutate(direction = ifelse(sstart > send, '-', '+'),
         sstart_dir = ifelse(sstart > send, send, sstart),
         send_dir = ifelse(sstart > send, sstart, send))

gene_cov_all_hits <- IRanges(blast_dir$sstart_dir, blast_dir$send_dir) %>% 
  split(., blast_dir$geneid) %>% 
  reduce() %>% 
  width %>% 
  sum %>% 
  data.frame

gene_cov_all_hits$length <- blast$slen[match(rownames(gene_cov_all_hits), 
                                  blast$geneid)]
gene_cov_all_hits$qcovall <- 100*gene_cov_all_hits$./gene_cov_all_hits$length
gene_cov_all_hits$geneid <- rownames(gene_cov_all_hits)

gene_cov_all_hits <- merge(merge(gene_cov_all_hits, 
            total_tpm_ofBlast),
      total_counts_ofBlast)

plot(gene_cov_all_hits$qcovall, 
     log1p(gene_cov_all_hits$total_tpm))

```

# Are the genes not found by Trinity detected with lower count values than those in the assembly?

```{r counts_of_hits_v_nohits}
num_uniq_hits <- blast %>% 
  group_by(sseqid, geneid) %>% 
  summarise(num = n()) %>% 
  mutate(any_hits = ifelse(num >= 1, 'Yes', 'No')) %>% 
  arrange(geneid) %>% 
  filter(geneid %in% counts$Geneid)

total_counts <- counts %>%  
  rowwise() %>% 
  mutate(total_counts = sum(c_across(matches('SBP')))) %>% 
  ungroup %>% 
  select(c('Geneid','total_counts'))

total_counts_BlastHits <- mutate(total_counts,
       any_hits = ifelse(Geneid %in% num_uniq_hits$geneid, 'Yes', 'No'))

total_tpm <- sbp %>%  
  rowwise() %>% 
  mutate(total_tpm = sum(c_across(matches('SBP')))) %>% 
  ungroup %>% 
  select(c('Geneid','total_tpm'))

total_tpm_BlastHits <- mutate(total_tpm,
       any_hits = ifelse(Geneid %in% num_uniq_hits$geneid, 'Yes', 'No'))

boxplot(log1p(total_counts) ~ any_hits , data = total_counts_BlastHits)
# boxplot(log1p(total_tpm) ~ any_hits , data = total_tpm_BlastHits)
```


```{r wilcox_test}
wilcox.test(total_counts$total_counts[total_tpm_BlastHits$any_hits == 'No'], 
            total_counts$total_counts[total_tpm_BlastHits$any_hits == 'Yes'])
```

#What's the lowest count/tpm assembled gene and the highest count/tpm undetected gene?

```{r high_count_unassembled}
total_counts_BlastHits %>% 
  group_by(any_hits) %>% 
  filter(any_hits == 'No') %>% 
  dplyr::slice_max(total_counts, n = 5)

total_tpm_BlastHits %>%
  group_by(any_hits) %>%
  filter(any_hits == 'No') %>% 
  dplyr::slice_max(total_tpm, n = 5)
```


```{r low_count_assembled}
total_counts_BlastHits %>% 
  group_by(any_hits) %>% 
  dplyr::slice_min(total_counts, n = 5) %>% 
  filter(any_hits == 'Yes') 

total_tpm_BlastHits %>% 
  group_by(any_hits) %>% 
  dplyr::slice_min(total_tpm, n = 5) %>% 
  filter(any_hits == 'Yes')
```

```{r assemblies_of_low_counts}
genes_low_count_assembled <- total_counts_BlastHits %>% 
  group_by(any_hits) %>% 
  dplyr::slice_min(total_counts, n = 5) %>% 
  filter(any_hits == 'Yes') %>% 
  .$Geneid

blast %>% 
  filter(str_detect(sseqid, 
                    pattern = paste(genes_low_count_assembled, 
                                    collapse = '|'))) %>% 
  arrange(sseqid, evalue)
```


# The BLAST50 results

From the results of BLAST in which max top 50 results were included.

```{r blast50_data}
blast50 <- read.table('../../blast/trinityDeNovo_PirTranscriptsPccAS_blastn-maxhits50.outfmt6',
                        col.names = outfmt6_headers) %>% 
  mutate(geneid = str_extract(sseqid, 
                              pattern = '(?<=gene=).+(?=___or)'),
         sseqid = unlist(
           lapply(
             str_extract_all(sseqid, 
                             pattern = '(?<=gene=).+(?=___or)|(?<=gene_product=).+(?=___trans)'), 
             paste, 
             collapse = '_')
         )
  )
```

```{r num_hits_50}
blast50 %>% 
  group_by(sseqid) %>% 
  summarise(num = n(),
            max_id = max(pident),
            min_id = min(pident)) %>% 
  arrange(desc(num))
```

```{r num_hits_by_transcript}
blast50 %>% 
  group_by(qseqid) %>% 
  summarise(num = n(),
            num_pirs = length(unique(sseqid)),
            lens = paste0(max(length), ', ', min(length)),
            pident = paste0(max(pident),', ',min(pident)),
            pirs = paste0(unique(
              str_extract(sseqid, 
                          pattern = 'PCHAS_.{7}')
            ), 
            collapse = ', ')) %>% 
  arrange(desc(num))
```

A lot of transcripts map to many of the pirs, probably due to having highly similar sequence at points.

```{r pirs_with_uniq_transcript_matched}
blast50 %>% 
  group_by(qseqid) %>% 
  mutate(num_pirs = ifelse(length(unique(sseqid)) == 1, 
                           'Uniq', 
                           'Multimatch')) %>% 
  ungroup() %>% 
  group_by(sseqid) %>% 
  summarise(uniq_trans = length(unique(qseqid[num_pirs == 'Uniq'])),
            multi_trans = length(unique(qseqid[num_pirs == 'Multimatch'])),
            lens = paste0(max(length), ', ', min(length)),
            pident = paste0(max(pident),', ',min(pident)),
            transcripts = paste0(unique(qseqid), 
                                 collapse = ', ')) %>% 
  arrange(desc(uniq_trans), multi_trans)
```

Most number of transcripts that only BLAST to a single pir gene is 4, and the three pirs with this property all have 9-18 other transcripts that BLAST to other pirs. 'PCHAS_0101200_PIR_protein' and 'PCHAS_0302700_PIR_protein' have 3 unique transcripts BLASTing to them which do not match any other pir. Interestingly enough this isn't the case for any other pir transcript.. 'PCHAS_0302700' has syntenic orthologs in vinckei and yoelii species.
